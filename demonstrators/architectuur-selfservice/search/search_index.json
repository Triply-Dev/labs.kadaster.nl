{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welkom Welkom bij deze architectuur van de self-service GIS Architectuur van het Kadaster. Middels deze website beschrijven wij: Onze visie over Self-Service GIS naar de toekomst. Hoe onze huidige architectuur hierin voorziet. Wat dit betekent voor onze gebruikers. Lees meer:","title":"Introductie"},{"location":"#welkom","text":"Welkom bij deze architectuur van de self-service GIS Architectuur van het Kadaster. Middels deze website beschrijven wij: Onze visie over Self-Service GIS naar de toekomst. Hoe onze huidige architectuur hierin voorziet. Wat dit betekent voor onze gebruikers. Lees meer:","title":"Welkom"},{"location":"Architecture/","text":"Solution Architecture Uiteindelijk streven wij ernaar onze data zo laagdrempelig en integraal mogelijk beschikbaar te stellen. Dat gaat uiteraard niet vanzelf. In zijn totaliteit onderkennen wij een Solution Architecture voor de totale ontsluiting. Deze zullen we hier toelichten. Architectuur In de essentie begint onze gedachte bij de data. Hierbij doen we doelbewust geen uitspraken over de specifieke databronnen. De aanpak die wij schetsen is generiek en zal moeten werken voor verschillende soorten data en databronnen. Databronnen benaderbaar met SQL, Linked Data en REST (vanuit de bron) noemen we hier expliciet. Op deze typen bronnen hebben wij eerder succesvol linked data ontsloten. Wij ontsluiten deze bronnen middels GraphQL. ( zie ook GraphQL-ETL ) Vanuit deze bronnen maken/hebben wij een Linked Data specifiek model ( zie ook Modelling ) waarheen wij de brondata omzetten. Dit datamodel representeert vaak een vertaling die dicht op het oorspronkelijke datamodel van de bron ligt en is derhalve herkenbaar voor de dataset-eigenaar. Deze resulterende LD \u2013 registraties zijn vaak moeilijk te gebruiken zonder domeinkennis van de specifieke bron en diens datamodel. ( zie ook Linked Data ). Om die reden zetten we de data om naar \u00e9\u00e9n of meerdere views (datamodellen) wat dichter bij de wens van de gebruiker zitten. Dit is zichtbaar in de gele laag. ( zie ook Knowledge Graph ). Uiteindelijk bieden we op basis van standaard services (bijv. REST / ElasticSearch / SPARQL / GraphQL) verschillende stopcontacten waar een gebruiker middels zijn applicatie op kan aansluiten. Hierbij interpreteren we een applicatie als een breed begrip. Zo is de metadata bijvoorbeeld ook gemakkelijk vindbaar voor een zoekmachine als Google. ( zie ook Gebruik ). Kernprincipes Om tot deze solution architecture te komen zijn een aantal kernprincipes van belang die relevant zijn geweest in de totstandkoming. Deze principes zijn: Data komt zo dicht mogelijk bij de bron weg. Enkel noodzakelijke kopie\u00ebn worden gebruikt. Data lineage is van essentieel belang. Het moet bij alle data herkenbaar zijn waar deze zijn oorsprong vindt. De Data Governance is duidelijk. Ieder tussenproduct van de data heeft een duidelijke eigenaar. Tussenproducten in de architectuur dienen allemaal een doel . Data wordt niet onnodig ontsloten. Data is rijk aan metadata en semantiek . Dit is onderdeel van de data die wij ontsluiten.","title":"Overview"},{"location":"Architecture/#solution-architecture","text":"Uiteindelijk streven wij ernaar onze data zo laagdrempelig en integraal mogelijk beschikbaar te stellen. Dat gaat uiteraard niet vanzelf. In zijn totaliteit onderkennen wij een Solution Architecture voor de totale ontsluiting. Deze zullen we hier toelichten.","title":"Solution Architecture"},{"location":"Architecture/#architectuur","text":"In de essentie begint onze gedachte bij de data. Hierbij doen we doelbewust geen uitspraken over de specifieke databronnen. De aanpak die wij schetsen is generiek en zal moeten werken voor verschillende soorten data en databronnen. Databronnen benaderbaar met SQL, Linked Data en REST (vanuit de bron) noemen we hier expliciet. Op deze typen bronnen hebben wij eerder succesvol linked data ontsloten. Wij ontsluiten deze bronnen middels GraphQL. ( zie ook GraphQL-ETL ) Vanuit deze bronnen maken/hebben wij een Linked Data specifiek model ( zie ook Modelling ) waarheen wij de brondata omzetten. Dit datamodel representeert vaak een vertaling die dicht op het oorspronkelijke datamodel van de bron ligt en is derhalve herkenbaar voor de dataset-eigenaar. Deze resulterende LD \u2013 registraties zijn vaak moeilijk te gebruiken zonder domeinkennis van de specifieke bron en diens datamodel. ( zie ook Linked Data ). Om die reden zetten we de data om naar \u00e9\u00e9n of meerdere views (datamodellen) wat dichter bij de wens van de gebruiker zitten. Dit is zichtbaar in de gele laag. ( zie ook Knowledge Graph ). Uiteindelijk bieden we op basis van standaard services (bijv. REST / ElasticSearch / SPARQL / GraphQL) verschillende stopcontacten waar een gebruiker middels zijn applicatie op kan aansluiten. Hierbij interpreteren we een applicatie als een breed begrip. Zo is de metadata bijvoorbeeld ook gemakkelijk vindbaar voor een zoekmachine als Google. ( zie ook Gebruik ).","title":"Architectuur"},{"location":"Architecture/#kernprincipes","text":"Om tot deze solution architecture te komen zijn een aantal kernprincipes van belang die relevant zijn geweest in de totstandkoming. Deze principes zijn: Data komt zo dicht mogelijk bij de bron weg. Enkel noodzakelijke kopie\u00ebn worden gebruikt. Data lineage is van essentieel belang. Het moet bij alle data herkenbaar zijn waar deze zijn oorsprong vindt. De Data Governance is duidelijk. Ieder tussenproduct van de data heeft een duidelijke eigenaar. Tussenproducten in de architectuur dienen allemaal een doel . Data wordt niet onnodig ontsloten. Data is rijk aan metadata en semantiek . Dit is onderdeel van de data die wij ontsluiten.","title":"Kernprincipes"},{"location":"Enhancer/","text":"GraphQL naar Linked Data: De Enhancer","title":"GraphQL naar Linked Data"},{"location":"Enhancer/#graphql-naar-linked-data-de-enhancer","text":"","title":"GraphQL naar Linked Data: De Enhancer"},{"location":"Gebruik/","text":"Gebruik van ons platform","title":"Overview"},{"location":"Gebruik/#gebruik-van-ons-platform","text":"","title":"Gebruik van ons platform"},{"location":"GraphQL/","text":"GraphQL","title":"GraphQL"},{"location":"GraphQL/#graphql","text":"","title":"GraphQL"},{"location":"GraphQLETL/","text":"Ontsluiting middels GraphQL GraphQL is een open-source framework oorspronkelijk ontwerpen door Facebook en tegenwoordig onderhouden door de GraphQL foundation. GraphQL is - vanuit hun eigen woorden - een querytaal voor APIs. Het combineert de gedachte van graafmodellering van je data en laagdrempelige ontsluiting via een developer-friendly API interface. Voordelen en doel van GraphQL Met GraphQL ondervangen we een aantal vaak gestelde tekortkomingen van de services die we op onze basisregistraties leveren. Levering van data is vraaggestuurd in plaats van aanbodgestuurd . We geven de gebruiker de kans om precies die data te bevragen die hij/zij nodig heeft. We maken bevragen op basis van objecten mogelijk. Verschillende datasets met een administratieve connectie kunnen integraal bevraagd worden. Voor ons heeft GraphQL echter twee belangrijke doelen: GraphQL is een krachtig paradigme om data integraal en laagdrempelig richting onze afnemers beschikbaar te stelen \u00e9n GraphQL dient als abstractielaag op de bron, om hiermee onze Extract- Transform & Load (ETL) van Linked Data uit te voeren. In dit document bespreken we nadrukkelijk dit eerste. Voor het tweede punt verwijzen we de ge\u00efnteresseerde lezer door naar de sectie over GraphQL in gebruik . GraphQL op een silo Verschillende GraphQL endpoints - naar de buitenwereld toe geidentificeerd door hun typedefs en resolvers - bevinden zich op een databron, zijnde (op dit moment) Linked Data, SQL en/of REST. Een GraphQL endpoint is dus back-end agnostisch. Typedefs Zoals eerder gesteld modelleren we middels GraphQL onze data als een graaf, met verschillende nodes (objecten) en edges (relaties). Deze modellering vinden we terug in de typedefs van ons GraphQL endpoint. Neem als voorbeeld het object Pand in de BAG. De corresponderende typedefs ziet er als volgt uit: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 \"\"\"Een pand is de kleinste bij de totstandkoming functioneel en bouwkundig-constructief zelfstandige eenheid die direct en duurzaam met de aarde is verbonden en betreedbaar en afsluitbaar is\"\"\" type BAG2Pand implements JSONLD @ key ( fields : \"lokaalid peilDatum\" ) { \"\"\"De identificatiecodes voor objecten zijn uniek binnen de context van deze naamgevingsruimte. Correspondeerd met de [NEN3610 standaard](https://geonovum.github.io/NEN3610-Linkeddata/#nen3610id)\"\"\" namespace : String ! \"\"\"Een aanduiding waarmee kan worden aangegeven dat een pand in de registratie is opgenomen als gevolg van een feitelijke constatering, zonder dat er op het moment van opname sprake was van een regulier brondocument voor deze opname. Zie ook [de BAG catalogus](https://imbag.github.io/catalogus/hoofdstukken/attributen--relaties#745-geconstateerd) \"\"\" geconstateerd : Boolean \"\"\"BAG registraties bevatten een voorkomen identificatie, waarmee de volgorde wordt aangegeven waarmee registraties voor hetzelfde object zijn aangemaakt.\"\"\" voorkomenidentificatie : Int \"\"\"Wordt gebruikt om de formele historie voor de bronhouder mee aan de duiden. Deze attribuut beschrijft wanneer het voorkomen is ontstaan bij de bronhouder. Zie ook [deze praktijkhandleiding](https://imbag.github.io/praktijkhandleiding/artikelen/hoe-bepaal-ik-welke-gegevens-in-een-levenscyclus-van-een-object-geldig-zijn)\"\"\" tijdstipregistratie : DateTime \"\"\"Wordt gebruikt om de formele historie voor de bronhouder mee aan de duiden. Deze attribuut beschrijft wanneer het voorkomen is afgesloten bij de bronhouder. Zie ook [deze praktijkhandleiding](https://imbag.github.io/praktijkhandleiding/artikelen/hoe-bepaal-ik-welke-gegevens-in-een-levenscyclus-van-een-object-geldig-zijn)\"\"\" eindregistratie : DateTime \"\"\"Wordt gebruikt om de materi\u00eble historie voor de bronhouder mee aan de duiden .De materi\u00eble historie beschrijft vanaf welke datum een voorkomen geldig is in de registratie, via het attribuut begingeldigheid. Deze datum kan in de toekomst liggen. Zie ook [deze praktijkhandleiding](https://imbag.github.io/praktijkhandleiding/artikelen/hoe-bepaal-ik-welke-gegevens-in-een-levenscyclus-van-een-object-geldig-zijn)\"\"\" begingeldigheid : Date \"\"\"Wordt gebruikt om de materi\u00eble historie voor de bronhouder mee aan de duiden .De materi\u00eble historie beschrijft tot welke datum een voorkomen geldig is in de registratie, via het attribuut eindgeldigheid. Deze datum kan in de toekomst liggen. Zie ook [deze praktijkhandleiding](https://imbag.github.io/praktijkhandleiding/artikelen/hoe-bepaal-ik-welke-gegevens-in-een-levenscyclus-van-een-object-geldig-zijn)\"\"\" eindgeldigheid : Date \"\"\"De unieke aanduiding van het brondocument op basis waarvan een opname, mutatie of een verwijdering van gegevens ten aanzien van een pand heeft plaatsgevonden binnen een gemeente.\"\"\" documentnummer : String \"\"\"De datum waarop het brondocument is vastgesteld op basis waarvan een opname, mutatie of een verwijdering van gegevens ten aanzien van een pand heeft plaatsgevonden.\"\"\" documentdatum : Date \"\"\"De minimaal tweedimensionale geometrische representatie van het bovenzicht van de omtrekken van een pand. Gemeten in het stelsel van de Rijksdriehoeksmeting. De [ESPG](https://epsg.io/28992) code van dit stelsel is 28992.\"\"\" geometrie : String @ jsonrdfprefix ( prefix : \"<http://www.opengis.net/def/crs/EPSG/0/28992> \" ) \"\"\"De aanduiding van het jaar waarin een pand oorspronkelijk als bouwkundig gereed is of zal worden opgeleverd.\"\"\" oorspronkelijkbouwjaar : Int ! \"\"\"De fase van de levenscyclus van een pand, waarin het betreffende pand zich bevindt. Domeinverzameling: - Bouw gestart - Bouwvergunning verleend - Niet gerealiseerd pand - Pand buiten gebruik - Pand gesloopt - Pand in gebruik - Pand in gebruik (niet ingemeten) - Sloopvergunning verleend \"\"\" pandstatus : String ! @ jsonrdftype \"\"\"Een verwijzing naar de Verblijfsobjecten en diens voorkomens (historie) welke deel uit maken van dit pand. Neemt alleen het actuele voorkomen wanneer peilDatum niet leeg is.\"\"\" bevatverblijfsobjecten : [ BAG2Verblijfsobject ] } Kortom, het object ( BAG2Pand ) kent attributen (bijv. oorspronkelijkBouwjaar ), verscheidene vormen van metadatering (zichtbaar in de typedefs) en object-relaties (zoals bevatVerblijfsobjecten ) waarmee relaties naar andere objecten worden aangegeven. Query Onderdeel van het implementeren van de typedefs is ook het defini\u00ebren van de Query varianten die voor deze silo geldt. Een Query defini\u00ebert de ingang waarmee de data bevraagd kan worden. Denk bijvoorbeeld aan een (set van) nummeraanduiding(en): bag2nummeraanduiding ( identificatiecode : String @ lpad ( length : 16 , char : \"0\" ), peilDatum : Date , first : Int , offset : Int ) : [ BAG2Nummeraanduiding ] Deze Query (ingang) beschrijft dus dat er een nummeraanduiding opgehaald kan worden voor een gegeven identificatiecode (vergelijkbaar met een standaard REST API) of dat er een set aan objecten opgehaald kan worden (met paginatie parameters first en offset ). Middels de zogenoemde directive lpad wordt input van een gebruiker voor identificatiecode automatisch aangevuld tot 16 karakters. Resolvers Wanneer de typedefs gedefini\u00eberd zijn moet het GraphQL endpoint nog weten hoe het de onderliggende data moet ophalen. Dit is terug te vinden in de resolvers. Een voorbeeldje: BAG2Nummeraanduiding : { hoofdadresVan ( parent , args , ctx , info ){ return querydb ({ pool : 'bag_pg' , ctx : bagsql [ \"bag2verblijfsobject\" ], id : \"hoofdadres = :identificatie\" , binds : { peildatum : parent . peilDatum , identificatie : parent . identificatiecode }}); }, } Kortom, de resolvers beschrijven hier dat er een voorgedefini\u00eberde SQL query ( bag2verlijfsobject ) moet worden afgevuurd met daarin een aantal bind variabelen (parameters) om van een object met type BAG2Nummeraanduiding het object op te halen dat het hoofdadresVan deze nummeraanduiding is. Middels de pool wordt aangegeven uit welke database de data moet komen. GraphQL over de silo's heen Al onze GraphQL endpoints voldoen aan de Apollo GraphQL standaard . Apollo is een open-source framework bovenop GraphQL waarmee voornamelijk federatie gemakkelijker is gemaakt. Wanneer verschillende GraphQL endpoints naar elkaar verwijzen (bijvoorbeeld doordat de onderliggende data relaties naar een andere databron bevat) gebruiken we Apollo om de brug tussen deze silo's te slaan. Dit betekent dat - governance technisch - data eigenaren verantwoordelijk zijn voor de data in hun eigen silo (en desbetreffende endpoint). Maar ook dat er middels een zogenoemde Apollo Gateway een bevraging kan worden uitgevoerd over deze verschillende silo's heen. Hierbij is het irrelevant waar deze endpoints staan. Voor deze endpoints geldt dus een volledige federated approach . De kracht hiervan is dat Kadaster niet per se een endpoint hoeft te hosten op alle data, maar dat ook externe partijen (zoals bijvoorbeeld CBS of NDW) een eigen endpoint zouden kunnen hosten, welke we dan wel weer integraal kunnen bevragen. Uiteraard wel zolang zij maar aan dezelfde standaarden voldoen. Om de silo's met elkaar te verbinden moeten er in de silo's zogenoemde extends worden aangebracht. Een voorbeeldje: extend type BGTPand @ key ( fields : \"identificatiebagpnd peilDatum\" ){ identificatiebagpnd : String @ external peilDatum : Date @ external \"\"\"In de BGT is voor het Pand object een relatie tot het afgeleide BAG pand opgenomen. Een BGT pand kan niet bestaan zonder onderliggend BAG pand. Dit is een verwijzing naar de bijbehorende voorkomens (historie) van het BAG pand. Alleen het actuele voorkomen wordt meegenomen wanneer peilDatum niet leeg is.\"\"\" bagpand : [ BAG2Pand ] } Hier wordt dus gesteld dat een BGTPand een relatie heeft met een BAGPand. En dat klopt. Een BGT Pand kan zelfs niet bestaan zonder BAG Pand . De identifier naar het BAG pand is dan ook een attribuut van het BGT Pand Object. Door in een extend aan te geven dat deze administratieve relatie bestaat, en een bijbehorende resolver te implementeren, kunnen beide objecten nu in samenhang worden bevraagd. GraphQL over Linked Data Voor onze toepassing geldt dat wij vaak GraphQL toepassen om traditionele data naar Linked Data te transformeren. Er zijn echter ook een scala aan toepassingen te bedenken waarom GraphQL ook een hele waardevolle abstractielaag kan bieden bovenop Linked Data. GraphQL is een breder geadopteerd query mechanisme dan SPARQL (de querytaal van Linked Data, red.) en biedt ook meer mogelijkheden om gemakkelijk door het schema heen te lopen. Het is dan ook mogelijk om een Linked Data endpoint met een (Apollo) GraphQL endpoint te abstraheren. Voor Linked Data endpoints geldt dat hier een communica implementatie met bijbehorende JSON-LD context (Zie bijvoorbeeld de JSON-LD context van BAG 2.0) bij hoort. Conclusie Een GraphQL endpoint is back-end agnostisch. Een GraphQL endpoint wordt gedefini\u00eberd door zijn typedefs en resolvers. GraphQL endpoints kunnen middels het Apollo framework geheel federatief worden opgezet en beheerd. Middels een Apollo GraphQL Gateway zijn de federatieve endpoints echter wel op \u00e9\u00e9n plek toegankelijk. GraphQL kan ook middels Communica dienen als abstractielaag voor een gegeven Linked Data bron. Een technische architectuur van dit geheel is te vinden in de volgende plaat: Terwijl we functioneel de volgende overzichtsplaat hanteren:","title":"GraphQL"},{"location":"GraphQLETL/#ontsluiting-middels-graphql","text":"GraphQL is een open-source framework oorspronkelijk ontwerpen door Facebook en tegenwoordig onderhouden door de GraphQL foundation. GraphQL is - vanuit hun eigen woorden - een querytaal voor APIs. Het combineert de gedachte van graafmodellering van je data en laagdrempelige ontsluiting via een developer-friendly API interface.","title":"Ontsluiting middels GraphQL"},{"location":"GraphQLETL/#voordelen-en-doel-van-graphql","text":"Met GraphQL ondervangen we een aantal vaak gestelde tekortkomingen van de services die we op onze basisregistraties leveren. Levering van data is vraaggestuurd in plaats van aanbodgestuurd . We geven de gebruiker de kans om precies die data te bevragen die hij/zij nodig heeft. We maken bevragen op basis van objecten mogelijk. Verschillende datasets met een administratieve connectie kunnen integraal bevraagd worden. Voor ons heeft GraphQL echter twee belangrijke doelen: GraphQL is een krachtig paradigme om data integraal en laagdrempelig richting onze afnemers beschikbaar te stelen \u00e9n GraphQL dient als abstractielaag op de bron, om hiermee onze Extract- Transform & Load (ETL) van Linked Data uit te voeren. In dit document bespreken we nadrukkelijk dit eerste. Voor het tweede punt verwijzen we de ge\u00efnteresseerde lezer door naar de sectie over GraphQL in gebruik .","title":"Voordelen en doel van GraphQL"},{"location":"GraphQLETL/#graphql-op-een-silo","text":"Verschillende GraphQL endpoints - naar de buitenwereld toe geidentificeerd door hun typedefs en resolvers - bevinden zich op een databron, zijnde (op dit moment) Linked Data, SQL en/of REST. Een GraphQL endpoint is dus back-end agnostisch.","title":"GraphQL op een silo"},{"location":"GraphQLETL/#typedefs","text":"Zoals eerder gesteld modelleren we middels GraphQL onze data als een graaf, met verschillende nodes (objecten) en edges (relaties). Deze modellering vinden we terug in de typedefs van ons GraphQL endpoint. Neem als voorbeeld het object Pand in de BAG. De corresponderende typedefs ziet er als volgt uit: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 \"\"\"Een pand is de kleinste bij de totstandkoming functioneel en bouwkundig-constructief zelfstandige eenheid die direct en duurzaam met de aarde is verbonden en betreedbaar en afsluitbaar is\"\"\" type BAG2Pand implements JSONLD @ key ( fields : \"lokaalid peilDatum\" ) { \"\"\"De identificatiecodes voor objecten zijn uniek binnen de context van deze naamgevingsruimte. Correspondeerd met de [NEN3610 standaard](https://geonovum.github.io/NEN3610-Linkeddata/#nen3610id)\"\"\" namespace : String ! \"\"\"Een aanduiding waarmee kan worden aangegeven dat een pand in de registratie is opgenomen als gevolg van een feitelijke constatering, zonder dat er op het moment van opname sprake was van een regulier brondocument voor deze opname. Zie ook [de BAG catalogus](https://imbag.github.io/catalogus/hoofdstukken/attributen--relaties#745-geconstateerd) \"\"\" geconstateerd : Boolean \"\"\"BAG registraties bevatten een voorkomen identificatie, waarmee de volgorde wordt aangegeven waarmee registraties voor hetzelfde object zijn aangemaakt.\"\"\" voorkomenidentificatie : Int \"\"\"Wordt gebruikt om de formele historie voor de bronhouder mee aan de duiden. Deze attribuut beschrijft wanneer het voorkomen is ontstaan bij de bronhouder. Zie ook [deze praktijkhandleiding](https://imbag.github.io/praktijkhandleiding/artikelen/hoe-bepaal-ik-welke-gegevens-in-een-levenscyclus-van-een-object-geldig-zijn)\"\"\" tijdstipregistratie : DateTime \"\"\"Wordt gebruikt om de formele historie voor de bronhouder mee aan de duiden. Deze attribuut beschrijft wanneer het voorkomen is afgesloten bij de bronhouder. Zie ook [deze praktijkhandleiding](https://imbag.github.io/praktijkhandleiding/artikelen/hoe-bepaal-ik-welke-gegevens-in-een-levenscyclus-van-een-object-geldig-zijn)\"\"\" eindregistratie : DateTime \"\"\"Wordt gebruikt om de materi\u00eble historie voor de bronhouder mee aan de duiden .De materi\u00eble historie beschrijft vanaf welke datum een voorkomen geldig is in de registratie, via het attribuut begingeldigheid. Deze datum kan in de toekomst liggen. Zie ook [deze praktijkhandleiding](https://imbag.github.io/praktijkhandleiding/artikelen/hoe-bepaal-ik-welke-gegevens-in-een-levenscyclus-van-een-object-geldig-zijn)\"\"\" begingeldigheid : Date \"\"\"Wordt gebruikt om de materi\u00eble historie voor de bronhouder mee aan de duiden .De materi\u00eble historie beschrijft tot welke datum een voorkomen geldig is in de registratie, via het attribuut eindgeldigheid. Deze datum kan in de toekomst liggen. Zie ook [deze praktijkhandleiding](https://imbag.github.io/praktijkhandleiding/artikelen/hoe-bepaal-ik-welke-gegevens-in-een-levenscyclus-van-een-object-geldig-zijn)\"\"\" eindgeldigheid : Date \"\"\"De unieke aanduiding van het brondocument op basis waarvan een opname, mutatie of een verwijdering van gegevens ten aanzien van een pand heeft plaatsgevonden binnen een gemeente.\"\"\" documentnummer : String \"\"\"De datum waarop het brondocument is vastgesteld op basis waarvan een opname, mutatie of een verwijdering van gegevens ten aanzien van een pand heeft plaatsgevonden.\"\"\" documentdatum : Date \"\"\"De minimaal tweedimensionale geometrische representatie van het bovenzicht van de omtrekken van een pand. Gemeten in het stelsel van de Rijksdriehoeksmeting. De [ESPG](https://epsg.io/28992) code van dit stelsel is 28992.\"\"\" geometrie : String @ jsonrdfprefix ( prefix : \"<http://www.opengis.net/def/crs/EPSG/0/28992> \" ) \"\"\"De aanduiding van het jaar waarin een pand oorspronkelijk als bouwkundig gereed is of zal worden opgeleverd.\"\"\" oorspronkelijkbouwjaar : Int ! \"\"\"De fase van de levenscyclus van een pand, waarin het betreffende pand zich bevindt. Domeinverzameling: - Bouw gestart - Bouwvergunning verleend - Niet gerealiseerd pand - Pand buiten gebruik - Pand gesloopt - Pand in gebruik - Pand in gebruik (niet ingemeten) - Sloopvergunning verleend \"\"\" pandstatus : String ! @ jsonrdftype \"\"\"Een verwijzing naar de Verblijfsobjecten en diens voorkomens (historie) welke deel uit maken van dit pand. Neemt alleen het actuele voorkomen wanneer peilDatum niet leeg is.\"\"\" bevatverblijfsobjecten : [ BAG2Verblijfsobject ] } Kortom, het object ( BAG2Pand ) kent attributen (bijv. oorspronkelijkBouwjaar ), verscheidene vormen van metadatering (zichtbaar in de typedefs) en object-relaties (zoals bevatVerblijfsobjecten ) waarmee relaties naar andere objecten worden aangegeven.","title":"Typedefs"},{"location":"GraphQLETL/#query","text":"Onderdeel van het implementeren van de typedefs is ook het defini\u00ebren van de Query varianten die voor deze silo geldt. Een Query defini\u00ebert de ingang waarmee de data bevraagd kan worden. Denk bijvoorbeeld aan een (set van) nummeraanduiding(en): bag2nummeraanduiding ( identificatiecode : String @ lpad ( length : 16 , char : \"0\" ), peilDatum : Date , first : Int , offset : Int ) : [ BAG2Nummeraanduiding ] Deze Query (ingang) beschrijft dus dat er een nummeraanduiding opgehaald kan worden voor een gegeven identificatiecode (vergelijkbaar met een standaard REST API) of dat er een set aan objecten opgehaald kan worden (met paginatie parameters first en offset ). Middels de zogenoemde directive lpad wordt input van een gebruiker voor identificatiecode automatisch aangevuld tot 16 karakters.","title":"Query"},{"location":"GraphQLETL/#resolvers","text":"Wanneer de typedefs gedefini\u00eberd zijn moet het GraphQL endpoint nog weten hoe het de onderliggende data moet ophalen. Dit is terug te vinden in de resolvers. Een voorbeeldje: BAG2Nummeraanduiding : { hoofdadresVan ( parent , args , ctx , info ){ return querydb ({ pool : 'bag_pg' , ctx : bagsql [ \"bag2verblijfsobject\" ], id : \"hoofdadres = :identificatie\" , binds : { peildatum : parent . peilDatum , identificatie : parent . identificatiecode }}); }, } Kortom, de resolvers beschrijven hier dat er een voorgedefini\u00eberde SQL query ( bag2verlijfsobject ) moet worden afgevuurd met daarin een aantal bind variabelen (parameters) om van een object met type BAG2Nummeraanduiding het object op te halen dat het hoofdadresVan deze nummeraanduiding is. Middels de pool wordt aangegeven uit welke database de data moet komen.","title":"Resolvers"},{"location":"GraphQLETL/#graphql-over-de-silos-heen","text":"Al onze GraphQL endpoints voldoen aan de Apollo GraphQL standaard . Apollo is een open-source framework bovenop GraphQL waarmee voornamelijk federatie gemakkelijker is gemaakt. Wanneer verschillende GraphQL endpoints naar elkaar verwijzen (bijvoorbeeld doordat de onderliggende data relaties naar een andere databron bevat) gebruiken we Apollo om de brug tussen deze silo's te slaan. Dit betekent dat - governance technisch - data eigenaren verantwoordelijk zijn voor de data in hun eigen silo (en desbetreffende endpoint). Maar ook dat er middels een zogenoemde Apollo Gateway een bevraging kan worden uitgevoerd over deze verschillende silo's heen. Hierbij is het irrelevant waar deze endpoints staan. Voor deze endpoints geldt dus een volledige federated approach . De kracht hiervan is dat Kadaster niet per se een endpoint hoeft te hosten op alle data, maar dat ook externe partijen (zoals bijvoorbeeld CBS of NDW) een eigen endpoint zouden kunnen hosten, welke we dan wel weer integraal kunnen bevragen. Uiteraard wel zolang zij maar aan dezelfde standaarden voldoen. Om de silo's met elkaar te verbinden moeten er in de silo's zogenoemde extends worden aangebracht. Een voorbeeldje: extend type BGTPand @ key ( fields : \"identificatiebagpnd peilDatum\" ){ identificatiebagpnd : String @ external peilDatum : Date @ external \"\"\"In de BGT is voor het Pand object een relatie tot het afgeleide BAG pand opgenomen. Een BGT pand kan niet bestaan zonder onderliggend BAG pand. Dit is een verwijzing naar de bijbehorende voorkomens (historie) van het BAG pand. Alleen het actuele voorkomen wordt meegenomen wanneer peilDatum niet leeg is.\"\"\" bagpand : [ BAG2Pand ] } Hier wordt dus gesteld dat een BGTPand een relatie heeft met een BAGPand. En dat klopt. Een BGT Pand kan zelfs niet bestaan zonder BAG Pand . De identifier naar het BAG pand is dan ook een attribuut van het BGT Pand Object. Door in een extend aan te geven dat deze administratieve relatie bestaat, en een bijbehorende resolver te implementeren, kunnen beide objecten nu in samenhang worden bevraagd.","title":"GraphQL over de silo's heen"},{"location":"GraphQLETL/#graphql-over-linked-data","text":"Voor onze toepassing geldt dat wij vaak GraphQL toepassen om traditionele data naar Linked Data te transformeren. Er zijn echter ook een scala aan toepassingen te bedenken waarom GraphQL ook een hele waardevolle abstractielaag kan bieden bovenop Linked Data. GraphQL is een breder geadopteerd query mechanisme dan SPARQL (de querytaal van Linked Data, red.) en biedt ook meer mogelijkheden om gemakkelijk door het schema heen te lopen. Het is dan ook mogelijk om een Linked Data endpoint met een (Apollo) GraphQL endpoint te abstraheren. Voor Linked Data endpoints geldt dat hier een communica implementatie met bijbehorende JSON-LD context (Zie bijvoorbeeld de JSON-LD context van BAG 2.0) bij hoort.","title":"GraphQL over Linked Data"},{"location":"GraphQLETL/#conclusie","text":"Een GraphQL endpoint is back-end agnostisch. Een GraphQL endpoint wordt gedefini\u00eberd door zijn typedefs en resolvers. GraphQL endpoints kunnen middels het Apollo framework geheel federatief worden opgezet en beheerd. Middels een Apollo GraphQL Gateway zijn de federatieve endpoints echter wel op \u00e9\u00e9n plek toegankelijk. GraphQL kan ook middels Communica dienen als abstractielaag voor een gegeven Linked Data bron. Een technische architectuur van dit geheel is te vinden in de volgende plaat: Terwijl we functioneel de volgende overzichtsplaat hanteren:","title":"Conclusie"},{"location":"KnowledgeGraph/","text":"Knowledge Graph","title":"Knowledge Graphs"},{"location":"KnowledgeGraph/#knowledge-graph","text":"","title":"Knowledge Graph"},{"location":"LinkedData/","text":"Linked Data","title":"Linked Data"},{"location":"LinkedData/#linked-data","text":"","title":"Linked Data"},{"location":"Modelling/","text":"Data Modelling","title":"Data Modelling"},{"location":"Modelling/#data-modelling","text":"","title":"Data Modelling"},{"location":"Pipeline/","text":"","title":"Pipeline"},{"location":"SparQL/","text":"Linked data ontsluiten middels SPARQL","title":"Linked Data (SPARQL)"},{"location":"SparQL/#linked-data-ontsluiten-middels-sparql","text":"","title":"Linked data ontsluiten middels SPARQL"},{"location":"UseCases/","text":"Use cases","title":"Overview"},{"location":"UseCases/#use-cases","text":"","title":"Use cases"},{"location":"Visie/","text":"Visie op Self-Service GIS Introductie Een belangrijke peiler het strategische meerjarenplan van het Kadaster is \u2018geo-informatie voor iedereen\u2019 te bieden en hiermee het beantwoorden van de meest relevante maatschappelijke vragen te ondersteunen. Hoewel we veel van de data die we momenteel hebben in een voor ontwikkelaars goed bruikbaar technisch format kunnen aanbieden, zal het beschikbaar stellen van data in andere formats en via andere middelen een breder scala aan gebruikers toegang geven om de data van het Kadaster te gebruiken. Onze langetermijnsvisie is om burgers de mogelijkheid te geven om zowel kadastergegevens als gegevens uit andere (open) bronnen te gebruiken, zodanig dat gebruikers de gegevens van Kadaster gemakkelijk kunnen verkennen en deze kunnen combineren met hun eigen gegevens. Daarnaast willen we ruimtelijke analyses van een bepaald niveau die gemakkelijk online (in de browser) kunnen worden uitgevoerd. Dit brengt de gegevens dichter bij de gebruiker, waardoor klanten zelf antwoorden op hun (ruimtelijke) vragen kunnen vinden. Een oplossing hiervoor is het gebruik van webtechnologie\u00ebn om deze \"self-service\" tool naar de eindgebruikers van het Kadaster te brengen in de vorm van een interactieve web mapping interface of web GIS (Geospatial Information System). De volgende pagina geeft enig inzicht in hoe \"self-service GIS\" kan worden bereikt binnen het Kadaster. Doelgroep Het doel van de ontwikkeling van deze self-service tool is om de betrokken gebruiker en actieve burger te voorzien van de middelen om ruimtelijke analyse uit te voeren, als ze proberen om een vraag te beantwoorden. Tot deze gebruikersgroep kan bijvoorbeeld een data- of onderzoeksjournalist behoren, die op zoek is naar een gedragspatroon, een potenti\u00eble nieuwe huiseigenaar die op zoek is naar milieu-informatie over zijn nieuwe woning of een lid van een woningcorporatie die de criminaliteit in zijn buurt wil onderzoeken. Deze gebruikersgroep is doorgaans niet goed thuis in de technische fijne kneepjes van ruimtelijke analyse en de mogelijkheden van een volwaardig GIS pakket, maar is gewoon ge\u00efnteresseerd in het gebruik van (een combinatie van) door het Kadaster verstrekte gegevens en de gegevens van andere aanbieders of hun eigen gegevens om een bepaalde ruimtelijke vraag te beantwoorden. Wat zijn de kenmerken van Self-Service GIS? Esri, de toonaangevende commerci\u00eble leverancier van geo-spatiale software en clouddiensten voor geo-informatie, definieert self-service GIS als een uitbreiding op de typische functionaliteit die binnen een web GIS wordt gevonden. Over het algemeen is een self-service GIS een applicatie die gemakkelijke interactie door de gebruiker en eenvoudige analyse van georuimtelijke gegevens via webgebaseerde geografische toepassingen, mogelijk maakt. Bij het bedienen van de bovengenoemde gebruikersgroep, wordt de vraag gesteld wat de features zijn van self-service GIS. Deze features kunnen zowel de functionaliteit bevatten, die beschikbaar moet zijn voor de gebruiker in de toepassing vanuit het perspectief van de gebruikersinterface, als ook welke gegevens of welke functies van deze gegevens beschikbaar moeten zijn voor de gebruiker in de webtoepassing. Om te bepalen wat de belangrijke features van self-service GIS zijn voor ons doel en de doelgroep van het Kadaster, kijken we ook naar de wensen vanuit onze klanten. Een analyse van welke ruimtelijke vragen de klanten van het Kadaster stellen, wordt uitgevoerd als onderdeel van een interne analyse van de gebruikersbehoeften. Welke vragen worden gesteld, zal benadrukken welke functionaliteit nuttig kan zijn voor de gebruikers in een selfservice GIS-toepassing. Het geeft ook inzicht in hoe gebruikers gebruik willen maken van de gegevens van het Kadaster en met welke andere gegevens de Kadastergegevens meestal worden gecombineerd bij het beantwoorden van ruimtelijke vragen. De features in de visie van het Kadaster voor self-service GIS, zijn ook afhankelijk van de technologische mogelijkheden en toekomstvisie voor het Kadaster als geheel.","title":"Visie"},{"location":"Visie/#visie-op-self-service-gis","text":"","title":"Visie op Self-Service GIS"},{"location":"Visie/#introductie","text":"Een belangrijke peiler het strategische meerjarenplan van het Kadaster is \u2018geo-informatie voor iedereen\u2019 te bieden en hiermee het beantwoorden van de meest relevante maatschappelijke vragen te ondersteunen. Hoewel we veel van de data die we momenteel hebben in een voor ontwikkelaars goed bruikbaar technisch format kunnen aanbieden, zal het beschikbaar stellen van data in andere formats en via andere middelen een breder scala aan gebruikers toegang geven om de data van het Kadaster te gebruiken. Onze langetermijnsvisie is om burgers de mogelijkheid te geven om zowel kadastergegevens als gegevens uit andere (open) bronnen te gebruiken, zodanig dat gebruikers de gegevens van Kadaster gemakkelijk kunnen verkennen en deze kunnen combineren met hun eigen gegevens. Daarnaast willen we ruimtelijke analyses van een bepaald niveau die gemakkelijk online (in de browser) kunnen worden uitgevoerd. Dit brengt de gegevens dichter bij de gebruiker, waardoor klanten zelf antwoorden op hun (ruimtelijke) vragen kunnen vinden. Een oplossing hiervoor is het gebruik van webtechnologie\u00ebn om deze \"self-service\" tool naar de eindgebruikers van het Kadaster te brengen in de vorm van een interactieve web mapping interface of web GIS (Geospatial Information System). De volgende pagina geeft enig inzicht in hoe \"self-service GIS\" kan worden bereikt binnen het Kadaster.","title":"Introductie"},{"location":"Visie/#doelgroep","text":"Het doel van de ontwikkeling van deze self-service tool is om de betrokken gebruiker en actieve burger te voorzien van de middelen om ruimtelijke analyse uit te voeren, als ze proberen om een vraag te beantwoorden. Tot deze gebruikersgroep kan bijvoorbeeld een data- of onderzoeksjournalist behoren, die op zoek is naar een gedragspatroon, een potenti\u00eble nieuwe huiseigenaar die op zoek is naar milieu-informatie over zijn nieuwe woning of een lid van een woningcorporatie die de criminaliteit in zijn buurt wil onderzoeken. Deze gebruikersgroep is doorgaans niet goed thuis in de technische fijne kneepjes van ruimtelijke analyse en de mogelijkheden van een volwaardig GIS pakket, maar is gewoon ge\u00efnteresseerd in het gebruik van (een combinatie van) door het Kadaster verstrekte gegevens en de gegevens van andere aanbieders of hun eigen gegevens om een bepaalde ruimtelijke vraag te beantwoorden.","title":"Doelgroep"},{"location":"Visie/#wat-zijn-de-kenmerken-van-self-service-gis","text":"Esri, de toonaangevende commerci\u00eble leverancier van geo-spatiale software en clouddiensten voor geo-informatie, definieert self-service GIS als een uitbreiding op de typische functionaliteit die binnen een web GIS wordt gevonden. Over het algemeen is een self-service GIS een applicatie die gemakkelijke interactie door de gebruiker en eenvoudige analyse van georuimtelijke gegevens via webgebaseerde geografische toepassingen, mogelijk maakt. Bij het bedienen van de bovengenoemde gebruikersgroep, wordt de vraag gesteld wat de features zijn van self-service GIS. Deze features kunnen zowel de functionaliteit bevatten, die beschikbaar moet zijn voor de gebruiker in de toepassing vanuit het perspectief van de gebruikersinterface, als ook welke gegevens of welke functies van deze gegevens beschikbaar moeten zijn voor de gebruiker in de webtoepassing. Om te bepalen wat de belangrijke features van self-service GIS zijn voor ons doel en de doelgroep van het Kadaster, kijken we ook naar de wensen vanuit onze klanten. Een analyse van welke ruimtelijke vragen de klanten van het Kadaster stellen, wordt uitgevoerd als onderdeel van een interne analyse van de gebruikersbehoeften. Welke vragen worden gesteld, zal benadrukken welke functionaliteit nuttig kan zijn voor de gebruikers in een selfservice GIS-toepassing. Het geeft ook inzicht in hoe gebruikers gebruik willen maken van de gegevens van het Kadaster en met welke andere gegevens de Kadastergegevens meestal worden gecombineerd bij het beantwoorden van ruimtelijke vragen. De features in de visie van het Kadaster voor self-service GIS, zijn ook afhankelijk van de technologische mogelijkheden en toekomstvisie voor het Kadaster als geheel.","title":"Wat zijn de kenmerken van Self-Service GIS?"}]}